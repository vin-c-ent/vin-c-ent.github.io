<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vincent Blog</title>
    <description>关于程序与设计 | 王润森，Full Stack Developer | 这里是 @Vincent王润森 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 24 Mar 2021 22:32:33 +0800</pubDate>
    <lastBuildDate>Wed, 24 Mar 2021 22:32:33 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Same origin policy</title>
        <description>&lt;h2 id=&quot;same-origin-policy--同源策略介绍&quot;&gt;Same Origin Policy / 同源策略介绍&lt;/h2&gt;

&lt;p&gt;在同源策略下，只有当A、B网页的origin相同的情况下，浏览器才会允许&lt;em&gt;A网页&lt;/em&gt;的scripts去访问&lt;em&gt;B网页&lt;/em&gt;的数据。&lt;/p&gt;

&lt;p&gt;这个策略防止了某些恶意script通过DOM (Document Object Model) 访问另一个网页的敏感信息&lt;/p&gt;

&lt;h2 id=&quot;origin的定义&quot;&gt;Origin的定义&lt;/h2&gt;

&lt;p&gt;Origin被定义为 URI scheme + host name + port number的组合&lt;/p&gt;

&lt;h2 id=&quot;sop的作用范围&quot;&gt;SOP的作用范围&lt;/h2&gt;

&lt;p&gt;SOP只会应用到script上。这意味着image, css, 和动态加载scripts可以通过对应的HTML tags被跨域访问。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fonts是一个值得注意的例外。&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;MDN Web Docs&lt;/em&gt;. Retrieved 2018-07-24. Web fonts are subject to the same domain restriction (font files must be on the same domain as the page using them), unless HTTP access controls  are used to relax this restriction.&lt;/p&gt;

  &lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;跨站请求伪造 (Cross-site request forgery, CSRF, XSRF)&lt;/em&gt; 就是利用同源策略不适用于&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTML标签&quot;&gt;HTML标签&lt;/a&gt;的缺陷。&lt;/p&gt;

&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;

&lt;p&gt;e.g. http://www.example.com/dir/page.html&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Compared URL&lt;/th&gt;
      &lt;th&gt;Outcome&lt;/th&gt;
      &lt;th&gt;Reason&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;http://www.example.com&lt;/strong&gt;/dir/page2.html&lt;/td&gt;
      &lt;td&gt;Success&lt;/td&gt;
      &lt;td&gt;Same scheme, host and port&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;http://www.example.com&lt;/strong&gt;/dir2/other.html&lt;/td&gt;
      &lt;td&gt;Success&lt;/td&gt;
      &lt;td&gt;Same scheme, host and port&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;http://&lt;/strong&gt;username:password@&lt;strong&gt;www.example.com&lt;/strong&gt;/dir2/other.html&lt;/td&gt;
      &lt;td&gt;Success&lt;/td&gt;
      &lt;td&gt;Same scheme, host and port&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;http://www.example.com:&lt;strong&gt;81&lt;/strong&gt;/dir/other.html&lt;/td&gt;
      &lt;td&gt;Failure&lt;/td&gt;
      &lt;td&gt;Same scheme and host but different port&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;https&lt;/strong&gt;://www.example.com/dir/other.html&lt;/td&gt;
      &lt;td&gt;Failure&lt;/td&gt;
      &lt;td&gt;Different scheme&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;http://&lt;strong&gt;en.example.com&lt;/strong&gt;/dir/other.html&lt;/td&gt;
      &lt;td&gt;Failure&lt;/td&gt;
      &lt;td&gt;Different host&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;http://&lt;strong&gt;example.com&lt;/strong&gt;/dir/other.html&lt;/td&gt;
      &lt;td&gt;Failure&lt;/td&gt;
      &lt;td&gt;Different host (exact match required)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;http://&lt;strong&gt;v2.www.example.com&lt;/strong&gt;/dir/other.html&lt;/td&gt;
      &lt;td&gt;Failure&lt;/td&gt;
      &lt;td&gt;Different host (exact match required)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;http://www.example.com:&lt;strong&gt;80&lt;/strong&gt;/dir/other.html&lt;/td&gt;
      &lt;td&gt;Depends&lt;/td&gt;
      &lt;td&gt;Port explicit.  Depends on implementation in browser.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;同源策略存在的意义&quot;&gt;同源策略存在的意义&lt;/h2&gt;

&lt;p&gt;这个机制对现代广泛依赖http cookies去维护用户session的web applications具有一个特殊意义。因为server基于http cookie的信息去暴露敏感信息或做状态改变的动作。client必要要维护在不相关站点提供的信息之间的严格隔离，从而可以防止数据机密性或完整性的缺失。&lt;/p&gt;

&lt;p&gt;假设没有同源限制，A网站的API可以被任何来源的AJAX请求访问，包括获取用户的隐私信息，只看用户有没有登录，现在有个坏人做了一个网站B，坏人在B网页中用AJAX访问A网站的API，如果一个用户访问B之前已经登录了A，那这个请求包含A网站的cookie信息，也就会被A网站认为用户已经登录，这样用户在A网站的隐私信息就泄露给了控制B网站的坏人。&lt;/p&gt;

&lt;p&gt;不过，如果A网站觉得一些信息跨站访问也无所谓，那就可以通过jsonp或者CORS规则暴露，关键是A网站主动允许不同源的请求。&lt;/p&gt;

&lt;h2 id=&quot;relaxing-the-same-origin-policy&quot;&gt;Relaxing the same-origin policy&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;数据污染 / Data tainting&lt;/li&gt;
  &lt;li&gt;document.domain property&lt;/li&gt;
  &lt;li&gt;Cross-Origin Resource Sharing&lt;/li&gt;
  &lt;li&gt;Cross-document messaging&lt;/li&gt;
  &lt;li&gt;JSONP&lt;/li&gt;
  &lt;li&gt;WebSockets&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/03/24/same-origin-policy/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/24/same-origin-policy/</guid>
        
        <category>HTTP</category>
        
        
      </item>
    
      <item>
        <title>Cookies</title>
        <description>&lt;h2 id=&quot;cookie介绍&quot;&gt;Cookie介绍&lt;/h2&gt;

&lt;p&gt;Cookie 保存在客户端中，按在客户端中的存储位置，可分为&lt;u&gt;内存 Cookie&lt;/u&gt; 和&lt;u&gt;硬盘 Cookie&lt;/u&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;u&gt;内存 Cookie&lt;/u&gt; : 由浏览器维护，保存在内存中，浏览器关闭即消失，存在时间短暂。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;u&gt;硬盘 Cookie&lt;/u&gt;  : 保存在硬盘里，有过期时间，除非用户手动清理或到了过期时间，硬盘 Cookie 不会清除，存在时间较长。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，按存在时间，可分为&lt;u&gt;非持久 Cookie&lt;/u&gt; 和&lt;u&gt;持久 Cookie&lt;/u&gt;。&lt;/p&gt;

&lt;h2 id=&quot;cookie存在的意义&quot;&gt;Cookie存在的意义&lt;/h2&gt;

&lt;p&gt;因为 HTTP 协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式 Web 应用程序的实现。&lt;/p&gt;

&lt;p&gt;在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 HTTP 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以 Cookie 就是用来绕开 HTTP 的无状态性的“额外手段”之一。服务器可以设置或读取 Cookies 中包含的信息，借此维护用户跟服务器会话中的状态。&lt;/p&gt;

&lt;p&gt;在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段 Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把 Cookie 发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段 Cookie 里追加新的商品信息。结帐时，服务器读取发送来的 Cookie 即可。&lt;/p&gt;

&lt;p&gt;Cookie 另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的 Cookie 到用户的硬盘上。第二次登录时，如果该 Cookie 尚未到期，浏览器会发送该 Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。&lt;/p&gt;

&lt;h2 id=&quot;domain--path属性&quot;&gt;Domain &amp;amp; Path属性&lt;/h2&gt;

&lt;p&gt;Domain和Path定义了cookie的scope，他们告诉了浏览器，cookie属于哪个网站。因为显而易见的安全原因，cookies只能被设置到当前resource的top domain和它的sub domains，而非其他top domain和sub domain。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例如，&lt;a href=&quot;http://example.org/&quot;&gt;example.org&lt;/a&gt;不能设置&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt;的cookies。因为这会允许&lt;a href=&quot;http://example.org/&quot;&gt;example.org&lt;/a&gt;去控制&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt;的cookies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果server没有指定一个cookie的domain和path，他们默认会设为请求resource的domain和path。&lt;/p&gt;

&lt;p&gt;然而，大多数的浏览器中，&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt; 没有主动设置domain的cookie和被设为&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt;的cookies是有区别的。&lt;/p&gt;

&lt;p&gt;在前一种情况，只有在到&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt;的request才会发送cookie，也称作host-only cookie。在后面一种case，所有的sub domain都会被发送 (e.g. &lt;a href=&quot;http://docs.foo.com/&quot;&gt;docs.foo.com&lt;/a&gt;)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个规则中有一个值得注意的是，Windows 10 RS3之前的Edge &amp;amp; IE11之前的和Windows 10 RS4 (April 2018) 的IE，无论cookie有没有设置domain属性，都会发送cookies到sub domains。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;下面是一个用户登录后，网站发送的一些Set-Cookie HTTP response headers的sample。http request被发送到&lt;a href=&quot;http://docs.foo.com/&quot;&gt;docs.foo.com&lt;/a&gt; subdomain的网页&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;HTTP/1.0 200 OK
Set-Cookie: LSID=DQAAAK…Eaem_vYg; Path=/accounts; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
Set-Cookie: HSID=AYQEVn…DKrdst; Domain=.foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; HttpOnly
Set-Cookie: SSID=Ap4P…GTEq; Domain=foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
…
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一个cookie, LSID, 没有Domain属性，但是Path属性被设置到/accounts。这告诉浏览器，cookie只会在请求页面在&lt;a href=&quot;http://docs.foo.com/accounts&quot;&gt;docs.foo.com/accounts&lt;/a&gt;下的时候被发送。(domain由request domain推断得出)&lt;/p&gt;

&lt;p&gt;另外2个cookies，HSID和SSID，当浏览器请求任何sub domain在.&lt;a href=&quot;http://foo.com/&quot;&gt;foo.com&lt;/a&gt;下，path任意的情况下会被发送 (e.g. www.foo.com/bra))。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在最近的standar中，前置的”.”是可选的，但仍然可以为了兼容基于RFC 2019的实现而增加。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;cookie-的缺陷&quot;&gt;Cookie 的缺陷&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Cookie 会被附加在每个 HTTP 请求中，所以无形中增加了&lt;strong&gt;流量&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;由于 HTTP 请求中的 Cookie 是明文传递的，所以&lt;strong&gt;安全性&lt;/strong&gt;成问题，除非使用&lt;strong&gt;https&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;Cookie 的&lt;strong&gt;大小&lt;/strong&gt;限制在 4 KB 左右，对于复杂的存储需求来说是不够用的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;偷窃cookies和脚本攻击&quot;&gt;偷窃Cookies和脚本攻击&lt;/h2&gt;

&lt;p&gt;虽然Cookies没有中电脑病毒那么危险，但它仍包含了一些敏感消息：用户名、电脑名、使用的浏览器和曾经访问的网站。用户不希望这些内容泄漏出去，尤其是当其中还包含有私人信息的时候。&lt;/p&gt;

&lt;p&gt;这并非危言耸听，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting&quot;&gt;跨站点脚本（XSS, Cross site scripting）&lt;/a&gt;可以达到此目的。在受到跨站点脚本攻击时，Cookie盗贼和Cookie投毒将窃取内容。一旦Cookie落入攻击者手中，它将会重现其价值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cookie盗贼：搜集用户Cookie并发给攻击者的黑客，攻击者将利用Cookie消息通过合法手段进入用户帐户。&lt;/li&gt;
  &lt;li&gt;Cookie投毒：一般认为，Cookie在储存和传回服务器期间没有被修改过，而攻击者会在Cookie送回服务器之前对其进行修改，达到自己的目的。例如，在一个购物网站的Cookie中包含了顾客应付的款项，攻击者将该值改小，达到少付款的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cookies的替代品&quot;&gt;Cookies的替代品&lt;/h2&gt;

&lt;p&gt;鉴于Cookie的局限和反对者的声音，有如下一些替代方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://sourceforge.net/projects/brownie/&quot;&gt;Brownie方案&lt;/a&gt;（页面存档备份，存于互联网档案馆），是一项开放源代码工程，由SourceForge发起。Brownie曾被用以共享在不同域中的接入，而Cookies则被构想成单一域中的接入。这项方案已经停止开发s。&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;P3P，用以让用户获得更多控制个人隐私权利的协议。在浏览网站时，它类似于Cookie。这项方案也已经停止开发。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;在与服务器传输数据时，通过在地址后面添加唯一&lt;u&gt;查询串&lt;/u&gt;，让服务器识别是否合法用户，也可以避免使用Cookie。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/03/24/cookies/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/24/cookies/</guid>
        
        <category>HTTP</category>
        
        
      </item>
    
      <item>
        <title>InnoDB存储引擎</title>
        <description>&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;\img\mysql\InnoDb_enginee-architecture.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;innodb的多线程模型&quot;&gt;InnoDB的多线程模型&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Master Thread : 非常核心的后台线程，主要负责
    &lt;ol&gt;
      &lt;li&gt;将缓冲池中的数据异步刷新到磁盘
        &lt;ol&gt;
          &lt;li&gt;每一秒将redo log buffer刷新到redo log文件&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;IO Thread在InnoDB存储引擎中大量使用了&lt;strong&gt;AIO&lt;/strong&gt;（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。
    &lt;ol&gt;
      &lt;li&gt;IO Thread的工作主要是负责这些IO请求的回调（call back）处理。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Purge Thread : 事务被提交后，其所使用的&lt;strong&gt;undo log&lt;/strong&gt;可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。&lt;/li&gt;
  &lt;li&gt;Page Cleaner Thread
    &lt;ol&gt;
      &lt;li&gt;作用 : 将之前版本中&lt;strong&gt;脏页的刷新&lt;/strong&gt;操作都放入到单独的线程中来完成&lt;/li&gt;
      &lt;li&gt;目的 : 为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;读取
    &lt;ol&gt;
      &lt;li&gt;首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。
        &lt;ol&gt;
          &lt;li&gt;每个&lt;strong&gt;页&lt;/strong&gt;根据&lt;strong&gt;哈希值&lt;/strong&gt;平均分配到不同&lt;strong&gt;缓冲池实例&lt;/strong&gt;中&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;下一次再读相同的页时，首先判断该页是否在缓冲池中。
        &lt;ol&gt;
          &lt;li&gt;若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。&lt;/li&gt;
          &lt;li&gt;否则，读取磁盘上的页。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;修改
    &lt;ol&gt;
      &lt;li&gt;写入redo log buffer&lt;/li&gt;
      &lt;li&gt;当事务提交时 (会触发将redo log buffer写入redo log的动作)，写redo log, 写binlog&lt;/li&gt;
      &lt;li&gt;修改在缓冲池中的页&lt;/li&gt;
      &lt;li&gt;将脏页复制到double write buffer&lt;/li&gt;
      &lt;li&gt;顺序写写入double write file&lt;/li&gt;
      &lt;li&gt;然后再以一定的频率刷新到磁盘上。
        &lt;ol&gt;
          &lt;li&gt;页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为&lt;strong&gt;Checkpoint&lt;/strong&gt;的机制刷新回磁盘。同样，这也是为了提高数据库的整体性能。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;内存&quot;&gt;内存&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;缓冲池 (innodb_buffer_pool)&lt;/li&gt;
  &lt;li&gt;LRU List &amp;amp; Free List &amp;amp; Flush List&lt;/li&gt;
  &lt;li&gt;重做日志缓冲池 (redo log buffer)&lt;/li&gt;
  &lt;li&gt;额外内存池 (innodb_additional_mem_pool_size)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓冲池--一块内存区域通过内存的速度来弥补磁盘速度较慢对数据库性能的影响&quot;&gt;缓冲池 : 一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;作用 : 由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。&lt;/li&gt;
  &lt;li&gt;内容 :
&lt;img src=&quot;\img\mysql\InnoDb_enginee-buffer.png&quot; alt=&quot;Image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;缓冲池数量 : innodb_buffer_pool_instances&lt;/li&gt;
  &lt;li&gt;算法
    &lt;ol&gt;
      &lt;li&gt;缓冲池是通过&lt;strong&gt;LRU（Latest Recent Used，最近最少使用）算法&lt;/strong&gt;来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。&lt;/li&gt;
      &lt;li&gt;midpoint insertion strategy : 新读取到的页, 不是放到首部, 而是放在中间&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redo-log-buffer&quot;&gt;redo log buffer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InnoDB存储引擎首先将redo log信息先放入到redo log buffer，然后按一定频率将其刷新到重做日志文件。&lt;/li&gt;
  &lt;li&gt;重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。
    &lt;ol&gt;
      &lt;li&gt;innodb_log_buffer_size, 默认为8MB&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;redo log buffer刷新到外部磁盘的redo log的情况
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Master Thread每一秒&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;每个&lt;strong&gt;事务commit&lt;/strong&gt;时&lt;/li&gt;
      &lt;li&gt;当redo log buffer&lt;strong&gt;剩余空间&lt;/strong&gt;小于1/2时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;额外内存池&quot;&gt;额外内存池&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆 (heap) 的方式进行的&lt;/li&gt;
  &lt;li&gt;在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请
    &lt;ol&gt;
      &lt;li&gt;e.g. 分配了缓冲池 (innodb_buffer_pool)，但是每个缓冲池中的帧缓冲 (frame buffer) 还有对应的缓冲控制对象 (buffer control block) ，这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;脏页--当-内存数据页缓冲池的页-比-磁盘上的页-新的时候我们称这个内存页为脏页&quot;&gt;脏页 : 当 &lt;u&gt;内存数据页(缓冲池的页)&lt;/u&gt; 比 &lt;u&gt;磁盘上的页&lt;/u&gt; 新的时候，我们称这个内存页为脏页&lt;/h2&gt;

&lt;h2 id=&quot;刷脏页的时机&quot;&gt;刷脏页的时机&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;redo log写满时，没有空间了，此时需要将checkpoint向前推进，推进的这部分日志对应的脏页刷入到磁盘，此时所有的更新全部阻塞，此时写的性能变为0，必须待刷一部分脏页后才能更新。&lt;/li&gt;
  &lt;li&gt;系统内存不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘。&lt;/li&gt;
  &lt;li&gt;MySQL认为空闲的时间，这种没有性能问题。&lt;/li&gt;
  &lt;li&gt;mysql正常关闭之前，会把所有脏页刷入磁盘，不存在性能问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;write-ahead-log-wal&quot;&gt;Write Ahead Log (WAL)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;现存问题 : 如果在从缓冲池将页的新版本刷新到&lt;u&gt;磁盘&lt;/u&gt;时发生了宕机，那么数据就不能恢复了。&lt;/li&gt;
  &lt;li&gt;作用 : 避免发生数据丢失&lt;/li&gt;
  &lt;li&gt;内容 : 当事务提交时 (会触发将redo log buffer写入redo log的动作)，先写redo log，再修改页。
    &lt;ol&gt;
      &lt;li&gt;当由于发生宕机而导致数据丢失时，通过redo log来完成数据的恢复&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;checkpoint--在某些关键的时间点将-缓冲池中的-脏页-刷回到-磁盘&quot;&gt;checkpoint : 在某些关键的时间点将 &lt;u&gt;缓冲池中的 脏页&lt;/u&gt; 刷回到 &lt;u&gt;磁盘&lt;/u&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;前提
    &lt;ol&gt;
      &lt;li&gt;不可能每次有脏页就刷新回磁盘, 开销很大&lt;/li&gt;
      &lt;li&gt;redo log 和 缓冲池 不可能无限大
        &lt;ol&gt;
          &lt;li&gt;当&lt;u&gt;redo log&lt;/u&gt; 和 &lt;u&gt;缓冲池&lt;/u&gt; 无限大的时候, 不需要将 &lt;u&gt;缓冲池&lt;/u&gt; 的内容刷新到 &lt;u&gt;磁盘&lt;/u&gt; . 因为当发生宕机的时候, 完全可以通过redo log来恢复
            &lt;ol&gt;
              &lt;li&gt;但是 &lt;u&gt;缓冲池&lt;/u&gt; 不可能无限大, 而且内存比磁盘贵很多&lt;/li&gt;
              &lt;li&gt;但是 &lt;u&gt;redo log&lt;/u&gt; 无限大的话, 恢复需要太久时间&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;作用 :
    &lt;ol&gt;
      &lt;li&gt;缩短数据库的恢复时间&lt;/li&gt;
      &lt;li&gt;缓冲池 不够用时，将脏页刷新到磁盘&lt;/li&gt;
      &lt;li&gt;redo log 不可用时，刷新脏页&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;好处 :
    &lt;ol&gt;
      &lt;li&gt;缩短恢复时间 : 当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘, 只需对Checkpoint后的重做日志进行恢复&lt;/li&gt;
      &lt;li&gt;缓冲池 不够用的时候, 根据LRU算法会溢出最近最少使用的页, 如果是脏页 (也有可能是select, 就不是脏页了), 会强制执行check point, 刷新回磁盘.&lt;/li&gt;
      &lt;li&gt;redo log : 如果redo log还被需要时, 就必须强制产生check point, 将缓冲池中的page至少刷新到当前redo log的位置
        &lt;ol&gt;
          &lt;li&gt;前提 : 当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的&lt;/li&gt;
          &lt;li&gt;redo log 不再需要 : 即便是宕机, 数据库恢复也不需要恢复这部分redo log&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;种类
    &lt;ol&gt;
      &lt;li&gt;Sharp Checkpoint (default) : 数据库关闭时 将 所有的脏页 都刷新回 磁盘&lt;/li&gt;
      &lt;li&gt;Fuzzy Checkpoint : 只刷新一部分脏页
        &lt;ol&gt;
          &lt;li&gt;情况
            &lt;ol&gt;
              &lt;li&gt;Master Thread Checkpoint : [异步] [非阻塞] 以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘&lt;/li&gt;
              &lt;li&gt;FLUSH_LRU_LIST Checkpoint : [PageCleaner线程] [非阻塞] InnoDB存储引擎需要保证 LRU列表 中需要有差不多100个空闲页可供使用&lt;/li&gt;
              &lt;li&gt;Async/Sync Flush Checkpoint : redo log不可用的情况，这时需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。&lt;/li&gt;
              &lt;li&gt;Dirty Page too much Checkpoint : 脏页的数量超过某个百分比 (innodb_max_dirty_pages_pct)&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;插入缓冲-insert-buffer--提高对于非聚集索引插入的性能&quot;&gt;插入缓冲 (Insert Buffer) : 提高对于&lt;strong&gt;非聚集索引&lt;/strong&gt;插入&lt;strong&gt;的&lt;/strong&gt;性能&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Insert Buffer&lt;/strong&gt;和数据页一样，&lt;strong&gt;不是buffer&lt;/strong&gt;, 也是&lt;strong&gt;物理页&lt;/strong&gt;的一个组成部分&lt;/li&gt;
  &lt;li&gt;当表只有聚集索引时, 会构造一颗聚集索引的B+树
    &lt;ol&gt;
      &lt;li&gt;当插入聚集索引 (主键) 是&lt;strong&gt;顺序自增&lt;/strong&gt;的时候，不需要磁盘的随机读取, 速度非常快。
        &lt;ol&gt;
          &lt;li&gt;非顺序的情况 : 主键是UUID 或 指定了主键&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;当表中有非聚集索引 (普通索引) 时,
    &lt;ol&gt;
      &lt;li&gt;依旧会按照主键构造一颗聚集索引的B+树,&lt;/li&gt;
      &lt;li&gt;同时会构造一颗&lt;strong&gt;非聚集索引&lt;/strong&gt;的B+树
        &lt;ol&gt;
          &lt;li&gt;对于非聚集索引&lt;strong&gt;叶子节点&lt;/strong&gt;的插入不再是顺序的了，这时就需要&lt;strong&gt;离散&lt;/strong&gt;地访问非聚集索引页 (&lt;strong&gt;也是为什么表中有索引, 插入会变慢的原因&lt;/strong&gt;)&lt;/li&gt;
          &lt;li&gt;由于随机读取的存在而导致了插入操作性能下降&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;插入缓冲 :
    &lt;ol&gt;
      &lt;li&gt;对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中
        &lt;ol&gt;
          &lt;li&gt;若在，则直接插入&lt;/li&gt;
          &lt;li&gt;若不在，
            &lt;ol&gt;
              &lt;li&gt;则先放入到一个Insert Buffer对象中，好似欺骗数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个磁盘位置。&lt;/li&gt;
              &lt;li&gt;然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge (合并) 操作，&lt;/li&gt;
              &lt;li&gt;这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;启动插入缓冲的条件
    &lt;ol&gt;
      &lt;li&gt;索引是辅助索引 (secondary index) : 因为聚集索引是主键, 也要确保唯一性&lt;/li&gt;
      &lt;li&gt;索引不是唯一（unique）的 : 因为如果是唯一的话, 要确保现存的没有重复, 需要随机读, 这样插入缓冲就没意义了&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;change buffer :
    &lt;ol&gt;
      &lt;li&gt;insert buffer的升级, 不仅对insert, 还对update, delete都有对应的update buffer, delete buffer, purge buffer&lt;/li&gt;
      &lt;li&gt;对象 : 非唯一的辅助索引&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;两次写-double-write--解决部分写失效问题-确保可靠性&quot;&gt;两次写 (Double Write) : &lt;strong&gt;解决部分写失效问题&lt;/strong&gt;, 确保可靠性&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;部分写失效 : 当更新内存页到磁盘中时, 发生宕机, 导致页只写了一部分.&lt;/li&gt;
  &lt;li&gt;redo log也不能解决部分写失效的问题 : 因为redo log记录的是对页的物理操作&lt;/li&gt;
  &lt;li&gt;解决办法 :&lt;/li&gt;
  &lt;li&gt;对缓冲池的脏页进行刷新的流程
    &lt;ol&gt;
      &lt;li&gt;不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer&lt;/li&gt;
      &lt;li&gt;通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上 (因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大)&lt;/li&gt;
      &lt;li&gt;马上调用fsync函数，同步磁盘中的double write文件，避免缓冲写带来的问题&lt;/li&gt;
      &lt;li&gt;将doublewrite buffer中的页写入各个表空间文件中&lt;/li&gt;
      &lt;li&gt;恢复流程
        &lt;ol&gt;
          &lt;li&gt;从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件&lt;/li&gt;
          &lt;li&gt;再应用重做日志&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;架构
&lt;img src=&quot;\img\mysql\InnoDb_enginee-double_wrtite.png&quot; alt=&quot;Image&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;自适应哈希索引-adaptive-hash-index--对频繁访问的页-建立索引&quot;&gt;自适应哈希索引 (Adaptive Hash Index) : 对频繁访问的页, 建立索引&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Innodb会监控对表上各索引页的查询, 如果观察到建立哈希索引可以带来速度提升, 则建立哈希索引&lt;/li&gt;
  &lt;li&gt;要求
    &lt;ol&gt;
      &lt;li&gt;查询&lt;strong&gt;语句是一样的&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;以该模式&lt;strong&gt;访问了100次&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;页通过该模式&lt;strong&gt;访问了N次&lt;/strong&gt;, 其中N = 页中记录 / 16&lt;/li&gt;
      &lt;li&gt;只能是&lt;strong&gt;等于某个值&lt;/strong&gt;的查询, 其他查询 (e.g. 范围查询) 是不能使用自适应哈希索引的&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;性能提升
    &lt;ol&gt;
      &lt;li&gt;读取 &amp;amp; 写入 : 提升2倍&lt;/li&gt;
      &lt;li&gt;辅助索引 : 连接性能提升5倍&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;设计思想 : 数据库的自优化 (self-tuning)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;异步io-async-io&quot;&gt;异步IO (Async IO)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;同时发出多个IO请求&lt;/li&gt;
  &lt;li&gt;IO merge : 当判断到多个页是连续的, 可以将多个IO操作合并为1个IO, 提高IO per second 性能&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;刷新邻接页-flush-neighbor-page&quot;&gt;刷新邻接页 (Flush Neighbor Page)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。&lt;/li&gt;
  &lt;li&gt;通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/02/23/innodb/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/02/23/innodb/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>Spring Boot 启动过程源码剖析</title>
        <description>&lt;h2 id=&quot;spring-boot-启动过程&quot;&gt;Spring Boot 启动过程&lt;/h2&gt;

&lt;p&gt;其实整个 spring boot的启动过程,目标都是为了实例化 application context&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;new SpringApplication
    &lt;ul&gt;
      &lt;li&gt;确定实例化的 application context的类型
        &lt;ul&gt;
          &lt;li&gt;用classloaderclass去看是否能load到对应的 load到就代表配置了,load不到就代表没配置&lt;/li&gt;
          &lt;li&gt;有3种类型
            &lt;ul&gt;
              &lt;li&gt;None&lt;/li&gt;
              &lt;li&gt;Servlet&lt;/li&gt;
              &lt;li&gt;REACTIVE&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;get application context initializer
        &lt;ul&gt;
          &lt;li&gt;load META–inf/spring. factories:从jar包里面找到所有的 spring.factories&lt;/li&gt;
          &lt;li&gt;从里面取出key (interface) 为org.springframework.context.ApplicationContextInitializer的class&lt;/li&gt;
          &lt;li&gt;实例化，并加入到ApplicationContext里面&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;get application listener
        &lt;ul&gt;
          &lt;li&gt;从上一步的cache里面取出key (interface) 为org. springframework.context.ApplicationListener的class&lt;/li&gt;
          &lt;li&gt;实例化，并加入到ApplicationContext里面&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;找到main class
        &lt;ul&gt;
          &lt;li&gt;这里用到了一个比较tricky的方法。为了找到main class，它先是new了一个RuntimeException，然后 getStackTrace，然后forloop找到 method name是”main”的StackTraceElement，最后拿到它的 class name&lt;/li&gt;
          &lt;li&gt;不过这里有个不懂的地方,因为我们已经传入了 primarySources,而这个正是 main method存在的class，不懂为什么不直接用这个。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;run(args)
    &lt;ul&gt;
      &lt;li&gt;new SpringApplicationRunListeners()
        &lt;ul&gt;
          &lt;li&gt;从cache里面取出key (interface) 为org. springframework.boot.SpringApplicationRunListener的class&lt;/li&gt;
          &lt;li&gt;实例化,并作为listeners参数来new SpringApplicationRunListeners&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;广播starting event
        &lt;ul&gt;
          &lt;li&gt;forloop SpringApplicationRunListener里面的listener，调用他们的starting()
            &lt;ul&gt;
              &lt;li&gt;里面其实就是在广播 ApplicationStartingEvent&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 30 Nov 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/11/30/spring-boot/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/11/30/spring-boot/</guid>
        
        <category>Spring Boot</category>
        
        
      </item>
    
      <item>
        <title>context switch</title>
        <description>&lt;h1 id=&quot;what-is-context-switch&quot;&gt;What is context switch&lt;/h1&gt;

&lt;p&gt;Nowadays, we often use computer for multiple tasks at the same time even it just contains 1 CPU. You might think that each CPU is actually able to execute multiple tasks at the same time? That is totally wrong. Actually each CPU in the computer can only execute one task at the same time. The reason why we got the previous illusion is that CPU switch too fast for us to notice. And we call each of this short moment (ms level) &lt;strong&gt;Time Slice&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If we compare &lt;u&gt;task&lt;/u&gt; to a &lt;u&gt;car&lt;/u&gt;, then &lt;u&gt;time slice&lt;/u&gt; is the &lt;u&gt;fuel oil&lt;/u&gt;. Without fuel oil, car is not runnable. So is the relationship between time slice and thread.&lt;/p&gt;

&lt;p&gt;And time slice will be allocated by CPU for executing a specific thread. No matter how short it is, once a thread owns a time slice lucky, this thread is runnable. And once time slice come to an end, CPU will store the progress of this thread, which we call &lt;strong&gt;context&lt;/strong&gt;, and look for the next lucky thread, and load its context.&lt;/p&gt;

&lt;p&gt;This is what we called &lt;strong&gt;context switch&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As the time slice is short enough, so our human being is not able to be aware of the switching, which make us feel like that our computer is running multiple tasks at the same time. But actually our CPU is working so hard to switch among multiple threads.&lt;/p&gt;

&lt;h2 id=&quot;pros--cons&quot;&gt;pros &amp;amp; cons&lt;/h2&gt;

&lt;p&gt;So now, it is obvious that the pros of context switch is that even 1 CPU can execute multiple task “at the same time”. Just like you hire a staff in a bank, while he is able to serve for multiple counter, how exciting it is.&lt;/p&gt;

&lt;p&gt;But every coin has two sides.&lt;/p&gt;

&lt;p&gt;The cons is also obvious, that is, you need to spend more effort on &lt;strong&gt;switching&lt;/strong&gt;, which is not related to the real task. What`s worse, if the task/thread grows more and more, and it will consume all you memory for the context.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;So how could we reducer the context switching? Below are 4 useful ways :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lockless : a lock is scrapped by multiple thread is one of the reason why we need context switch frequently. So we should try our best to avoid using lock during the multiple thread scenario. e.g.
    &lt;ul&gt;
      &lt;li&gt;Use ConcurrentHashMap, whose segment lock will separate the id according to the hash algorithm, so that different thread will handle the data in different segment.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CAS : Optimistic lock, no lock is required.&lt;/li&gt;
  &lt;li&gt;With minimal thread : the more thread it is, the more thread is waiting.&lt;/li&gt;
  &lt;li&gt;Coroutine : existed in framework, not supported by JDK.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 28 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/28/context-switch/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/28/context-switch/</guid>
        
        <category>Concurrence</category>
        
        
      </item>
    
      <item>
        <title>Redis introduction</title>
        <description>&lt;h2 id=&quot;什么是redis&quot;&gt;什么是Redis&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;内存数据库&lt;/li&gt;
  &lt;li&gt;非关系型数据库  (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;数据库不需要被预定义&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;有5种独特的数据类型&lt;/li&gt;
  &lt;li&gt;特性
    &lt;ul&gt;
      &lt;li&gt;可持久化&lt;/li&gt;
      &lt;li&gt;可复制 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展读性能 &amp;amp; 提供故障转移&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;可客户端分片 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展写性能&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redis的好处&quot;&gt;Redis的好处&lt;/h2&gt;

&lt;h4 id=&quot;为什么-redis-单线程模型也能效率这么高&quot;&gt;为什么 redis 单线程模型也能效率这么高？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;纯&lt;strong&gt;内存操作&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;核心是基于&lt;strong&gt;非阻塞的 IO 多路复用&lt;/strong&gt;机制 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;像Windows一样的事件处理机制&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;采用&lt;strong&gt;单线程&lt;/strong&gt;，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    &lt;ul&gt;
      &lt;li&gt;Redis是基于内存的操作，CPU不是Redis的瓶颈 ，Redis的瓶颈最有可能是机器&lt;strong&gt;内存的大小&lt;/strong&gt;或者&lt;strong&gt;网络带宽&lt;/strong&gt; (&lt;strong&gt;也就是就算采用多线程去榨干CPU资源，还是得等网络带宽&lt;/strong&gt;)。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。&lt;/li&gt;
      &lt;li&gt;不过无法发挥多核CPU性能，但是可以通过在单机开多个Redis实例来完善；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据结构简单，对数据操作也简单，Redis中的&lt;strong&gt;数据结构是专门进行设计&lt;/strong&gt;的；&lt;/li&gt;
  &lt;li&gt;使用底层模型不同，它们之间底层实现方式以及与客户端之间&lt;strong&gt;通信的应用协议&lt;/strong&gt;不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;对比memcached&quot;&gt;对比memcached&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;相同点 :
    &lt;ul&gt;
      &lt;li&gt;都可用于存储key-value mapping&lt;/li&gt;
      &lt;li&gt;性能也相差无几&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Redis的优势 :
    &lt;ul&gt;
      &lt;li&gt;能够自动以两种不同的方式将数据写入到硬盘 (snapshot &amp;amp; AOF)&lt;/li&gt;
      &lt;li&gt;除了能存储普通的String key之外，还可以存储其他4种data structure&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;memcached的不足 :
    &lt;ul&gt;
      &lt;li&gt;只能存储普通的String key。
        &lt;ul&gt;
          &lt;li&gt;因为所有的value都是String，当要实现列表的时候，只能把String当作列表来使用。当要删除list里面某个元素时，memcached采用的方法时通过黑名单来隐藏列表里面的元素，从而避免对元素执行读取+更新+写入等操作。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;无法持久化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;memcached的优势
    &lt;ul&gt;
      &lt;li&gt;由于 redis 只使用单核，而 memcached 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis，虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;String
&lt;img src=&quot;\img\redis\redis-string.png&quot; alt=&quot;image-20200901095423867&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;List
&lt;img src=&quot;\img\redis\redis-list.png&quot; alt=&quot;image-20200901094745076&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Set
&lt;img src=&quot;\img\redis\redis-set.png&quot; alt=&quot;image-20200901094732166&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Hash
&lt;img src=&quot;\img\redis\redis-hash.png&quot; alt=&quot;image-20200901094719409&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;ZSet
&lt;img src=&quot;\img\redis\redis-zset.png&quot; alt=&quot;image-20200901094636092&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;持久化&quot;&gt;持久化&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;快照 (snapshotting) : 将存在于某一时刻的所有数据都写入到硬盘里面。
    &lt;ol&gt;
      &lt;li&gt;触发条件 :
        &lt;ol&gt;
          &lt;li&gt;在”指定时间段内有指定数量的写操作执行”这一条件被满足时执行;&lt;/li&gt;
          &lt;li&gt;通过调用两条转储到硬盘 (dump-to-disk) 命令种的任何一条来执行;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;只追加写入 : 将所有修改了redis的命令都写入到一个只追加文件 (append-only file, AOF) 里面，并设置同步频率
    &lt;ol&gt;
      &lt;li&gt;从不同步&lt;/li&gt;
      &lt;li&gt;每秒同步一次&lt;/li&gt;
      &lt;li&gt;每写入一个命令就同步一次&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;过期策略&quot;&gt;过期策略&lt;/h2&gt;

&lt;p&gt;业界如今有以下3种过期策略。redis采用的是&lt;strong&gt;定期删除&lt;/strong&gt; + &lt;strong&gt;惰性删除&lt;/strong&gt;策略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定期删除 : redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查 (如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
    &lt;ul&gt;
      &lt;li&gt;优点 :
        &lt;ul&gt;
          &lt;li&gt;频率可控。可以自定义检查的频率，”丰俭由人”。&lt;/li&gt;
          &lt;li&gt;成本可控。有限制地抽取特定数目的元素淘汰，不会干扰到Redis的服务。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点 : 因为是随机抽取，所以还是会有很多key到时间没有删除。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;惰性删除 : 查询某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
    &lt;ul&gt;
      &lt;li&gt;优点 : 一个兜底的策略，不会让过期的key继续提供value。&lt;/li&gt;
      &lt;li&gt;缺点 : 一直没被查询的话，过期了的key就不会被删除。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定时删除 : 用一个定时器来负责监视key,过期则自动删除。
    &lt;ul&gt;
      &lt;li&gt;优点 : 内存及时释放，&lt;/li&gt;
      &lt;li&gt;缺点 : 十分消耗CPU资源。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么不用定时删除策略？因为在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.&lt;/p&gt;

&lt;h2 id=&quot;内存淘汰机制&quot;&gt;内存淘汰机制&lt;/h2&gt;

&lt;p&gt;过期策略其实还不是足够完善。如果&lt;strong&gt;定期删除&lt;/strong&gt;没删除key。然后你也没即时去请求key，也就是说&lt;strong&gt;惰性删除&lt;/strong&gt;也没生效。这样，redis的内存会越来越高。那么就应该采用&lt;strong&gt;内存淘汰机制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在redis.conf中有一行配置&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# maxmemory-policy volatile-lru
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该配置就是配内存淘汰策略的&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;淘汰策略&lt;/th&gt;
      &lt;th&gt;详情&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;noeviction&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，新写入操作会报错。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;应该没人用吧&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;allkeys-lru&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;推荐使用，目前项目在用这种&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;allkeys-random&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;应该也没人用吧，你不删最少使用Key,去随机删&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;volatile-lru&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;volatile-random&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不推荐&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;volatile-ttl&lt;/td&gt;
      &lt;td&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。&lt;br /&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不推荐&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。&lt;/p&gt;

&lt;h2 id=&quot;redis常见问题&quot;&gt;Redis常见问题&lt;/h2&gt;

&lt;h4 id=&quot;缓存和数据库双写一致性问题&quot;&gt;缓存和数据库双写一致性问题&lt;/h4&gt;

&lt;p&gt;一致性问题是分布式常见问题，可以再分为&lt;strong&gt;最终一致性&lt;/strong&gt;和&lt;strong&gt;强一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;数据库和缓存双写，就必然会存在不一致的问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要强一致性
    &lt;ul&gt;
      &lt;li&gt;不能放缓存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;需要最终一致性
    &lt;ul&gt;
      &lt;li&gt;采取正确更新策略，先更新数据库，再删缓存。&lt;/li&gt;
      &lt;li&gt;可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓存穿透--击穿&quot;&gt;缓存穿透 / 击穿&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;穿透&lt;/strong&gt; 即网站遭受到恶意攻击，不断请求数据库中&lt;strong&gt;不存在的数据&lt;/strong&gt;，由于无法击中缓存，因此所有请求都会到达数据库，最终数据库不堪压力而连接异常。
解决方案如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用&lt;u&gt;互斥锁&lt;/u&gt;，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。&lt;/li&gt;
  &lt;li&gt;采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。&lt;/li&gt;
  &lt;li&gt;提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;布隆过滤器&quot;&gt;布隆过滤器&lt;/h6&gt;

&lt;p&gt;原理 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每新增一个元素，用若干个hash算法计算出其hashcode，然后将对应的bit array设为1。&lt;/li&gt;
  &lt;li&gt;查询是否存在时，用若干个hash算法计算出存在的元素的hashcode，然后看对应的bit array是否全为1
    &lt;ul&gt;
      &lt;li&gt;是 : 有可能存在&lt;/li&gt;
      &lt;li&gt;否 : 一定不存在&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓存雪崩&quot;&gt;缓存雪崩&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;雪崩&lt;/strong&gt; 即缓存&lt;strong&gt;同一时间&lt;/strong&gt;大面积的失效，这个时候会有大量请求同时到达数据库，导致数据库连接异常。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给缓存的失效时间，加上一个随机值，避免集体失效。&lt;/li&gt;
  &lt;li&gt;互斥锁，但该方案吞吐量明显下降。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;集群模式&quot;&gt;集群模式&lt;/h2&gt;

&lt;h2 id=&quot;redis的使用场景&quot;&gt;Redis的使用场景&lt;/h2&gt;

&lt;h3 id=&quot;如何使用redis做分布式锁&quot;&gt;如何使用Redis做分布式锁&lt;/h3&gt;

&lt;p&gt;实现分布式锁主要利用 redis 中set nx ex的API。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nx&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if not exists&lt;/code&gt;的缩写，当key已经存在了，则存储不成功，返回0。当key不存在时，操作成功，返回1。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expire time&lt;/code&gt;的缩写，在设这个key value的时候，同时设定过期时间。&lt;/p&gt;

&lt;p&gt;下面是一个分布式锁的 Java 实现:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringRedisTemplate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringRedisTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquirePaymentLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Instant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expireDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringRedisTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RedisCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;set&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; 
                &lt;span class=&quot;s&quot;&gt;&quot;nx&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; 
                &lt;span class=&quot;s&quot;&gt;&quot;ex&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expireSecondStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;failed to acquire lock&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PaymentLockException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GENERIC_ERROR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;OK&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 27 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/27/redis-introduction/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/27/redis-introduction/</guid>
        
        <category>Redis</category>
        
        
      </item>
    
      <item>
        <title>Hello Netty</title>
        <description>&lt;h2 id=&quot;when-netty-is-still-not-existed&quot;&gt;When Netty is still not existed&lt;/h2&gt;

&lt;h2 id=&quot;what-is-netty&quot;&gt;What is Netty&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Netty is &lt;em&gt;an &lt;strong&gt;asynchronous&lt;/strong&gt; &lt;strong&gt;event-driven&lt;/strong&gt; &lt;strong&gt;network&lt;/strong&gt; application framework&lt;/em&gt;
for &lt;strong&gt;rapid&lt;/strong&gt; development of maintainable &lt;strong&gt;high performance&lt;/strong&gt; protocol servers &amp;amp; clients.&lt;/p&gt;

  &lt;p&gt;Netty是一款&lt;strong&gt;异步&lt;/strong&gt;的&lt;strong&gt;事件驱动&lt;/strong&gt;的&lt;strong&gt;网络&lt;/strong&gt;应用程序框架，支持&lt;strong&gt;快速&lt;/strong&gt;地开发可维护的&lt;strong&gt;高性能&lt;/strong&gt;的面向协议的服务器和客户端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-benefit-of-netty&quot;&gt;The benefit of Netty&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;解耦了业务和网络逻辑&lt;/li&gt;
  &lt;li&gt;可测试性&lt;/li&gt;
  &lt;li&gt;面向接口编程。为OIO和NIO抽象出通用的API，实现了改一行代码就能转换。&lt;/li&gt;
  &lt;li&gt;封装了Java NIO的复杂性
    &lt;ol&gt;
      &lt;li&gt;Java NIO解决了每个请求都要new一个thread的痛点&lt;/li&gt;
      &lt;li&gt;Netty封装了Java NIO，让它更易用。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;NIO数据结构，比Java的ByteBuffer更好用。&lt;/li&gt;
  &lt;li&gt;线程模型&lt;/li&gt;
  &lt;li&gt;性能比Java NIO好&lt;/li&gt;
  &lt;li&gt;handler编排，流水线，能够处理以任意顺序到达的request。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;netty目前真实使用场景&quot;&gt;Netty目前真实使用场景&lt;/h2&gt;

&lt;h2 id=&quot;历史&quot;&gt;历史&lt;/h2&gt;

&lt;h2 id=&quot;组件&quot;&gt;组件&lt;/h2&gt;

&lt;h2 id=&quot;组件关系图&quot;&gt;组件关系图&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;h2 id=&quot;evolution-of-application-deployment&quot;&gt;Evolution of application deployment&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;C语言的套接字库&lt;/li&gt;
  &lt;li&gt;Java的 java.net包&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;portNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Socket&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverSoocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;扩展 : 只能针对整个系统。&lt;/li&gt;
  &lt;li&gt;将复杂的单体应用拆分为小的可独立部署的微服务组&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;benefit&quot;&gt;Benefit&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;封装了网络编程的复杂性。&lt;/li&gt;
  &lt;li&gt;定义了一种架构模型，使得业务逻辑与网络层解耦。&lt;/li&gt;
  &lt;li&gt;模块化 &amp;amp; 可复用性&lt;/li&gt;
  &lt;li&gt;可测试性&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 21 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/21/hello-netty/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/21/hello-netty/</guid>
        
        
      </item>
    
      <item>
        <title>Hello Kubernetes</title>
        <description>&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;以往的大型单体应用由于无法频繁迭代、独立开发等原因，正逐渐被拆分成小的、可独立运行的组件，我们称之为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;微服务&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;微服务彼此之间解耦，所以具备独立开发、部署、升级、伸缩等优点，使得我们可以对每一个微服务实现快速迭代，并且迭代速度与市场需求变化速度保持一致。&lt;/p&gt;

&lt;p&gt;但是随着部署组件的增多，配置、管理并保持系统的正常运行变得越来越困难。手动做所有的事情，显然不太可行。于是我们需要一些自动化的措施，包括自动调度、配置、监管和故障处理。这正是&lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;的用武之地。&lt;/p&gt;

&lt;h2 id=&quot;evolution-of-application-deployment&quot;&gt;Evolution of application deployment&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;组件之间紧密耦合在一个单体应用中。但是这种方式不利于开发、部署、扩展。
    &lt;ul&gt;
      &lt;li&gt;开发 : 容易发生依赖冲突。&lt;/li&gt;
      &lt;li&gt;部署 : 哪怕一个小功能都要整个系统停机更新。&lt;/li&gt;
      &lt;li&gt;扩展 : 只能针对整个系统。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将复杂的单体应用拆分为小的可独立部署的微服务组件。并通过网络通信。
    &lt;ul&gt;
      &lt;li&gt;开发 : 可以自己选择合适的依赖。&lt;/li&gt;
      &lt;li&gt;部署 : 粒度更细，只需要部署需要改变的服务。&lt;/li&gt;
      &lt;li&gt;扩展 : 粒度更细，可以针对单个服务进行扩展。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-kubernetes&quot;&gt;What is Kubernetes&lt;/h3&gt;

&lt;p&gt;Kubernetes是希腊语中的 “领航员” 或 “舵手” 的意思，我们一般简称它为K8S (因为K和S之间有8个单词)。&lt;/p&gt;

&lt;p&gt;它抽象了数据中心的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;硬件基础设施&lt;/code&gt;，使得对外暴露的只是一个巨大的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源池&lt;/code&gt;。它让我们在部署和运行组件时，不用关注底层的服务器。&lt;/p&gt;

&lt;p&gt;使用K8S部署多组件应用时，它会为每个组件都选择一个合适的服务器，部署之后它能够保证每个组件可以轻易地发现其他组件，并彼此之间实现通信。&lt;/p&gt;

&lt;p&gt;All in all, K8S帮助企业标准化了无论是云端部署还是内部部署的应用交付方式。&lt;/p&gt;

&lt;h3 id=&quot;benefit-of-kubernetes&quot;&gt;Benefit of Kubernetes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;让开发者可以脱离运维团队的帮助，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自主部署应用&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;监控整个系统&lt;/code&gt;。让系统管理员的重心从监管应用转移到了监管Kubernetes。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 14 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/14/hello-kubernetes/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/14/hello-kubernetes/</guid>
        
        <category>K8S</category>
        
        
      </item>
    
      <item>
        <title>Hello 2020</title>
        <description>&lt;h2 id=&quot;hello-blog&quot;&gt;Hello Blog&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在毕业后的第5年，之前拖延了许久的blog，终于也开通了。&lt;/p&gt;

&lt;p&gt;说实话，之前一直徘徊于开通与不开通之间。无论开通还是不开通，都有各自的理由去说服对方。&lt;/p&gt;

&lt;p&gt;说开通吧，一来懒得折腾，二来弄了也觉得没什么用，毕竟有东西也可以记在一些笔记软件里面。&lt;/p&gt;

&lt;p&gt;说不开通吧，一直记在笔记软件里面，又似乎欠缺了些交流，也不能锻炼自己的写作能力。&lt;/p&gt;

&lt;p&gt;这人啊，有时候目的性太强，反而什么都干不成，这就是想得太多，做得太少吧，太计较得失，聪明反被聪明误。就像热血动漫里面的主角，不顾后果，不想以后，只专注于眼前，反而可以成功。所以趁最近有几天假期，就闷头苦干去弄好这博客算了。也算了却一桩心事，让自己点点滴滴的进步有个家。&lt;/p&gt;

&lt;h2 id=&quot;2020&quot;&gt;2020&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;无论现在你觉得过得有多好，要是不能持续进步，你都要放弃掉，去往下一个更大的天地。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2020是一个多事之年，新冠肺炎，中美贸易战，以及他们带来的一系列连锁反应，无不影响着我们老百姓的生活。&lt;/p&gt;

&lt;p&gt;我个人也离开了工作3年的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accenture&lt;/code&gt;，从广州去了深圳。无他，就是趁年轻，多点历练，多看看其他公司的项目是怎样的。&lt;/p&gt;

&lt;p&gt;离开之前，上司Chris知道我的想法也有劝说过内部换项目 (真的很感谢)。但是想着既然要变，就变得彻彻底底，索性换公司算了，还能体验下其他公司文化氛围是怎样的。&lt;/p&gt;

&lt;p&gt;其实2019也动了想走的念头了，一来因为家里有宝宝出生，忙不过来。二来因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accenture&lt;/code&gt;真的是一家让人很舒服的公司。所以才一拖再拖。&lt;/p&gt;

&lt;p&gt;新公司是深圳的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OCBC&lt;/code&gt;。新同事都挺nice的，没有办公室政治，暂时也不忙，也能锻炼到自己荒废了许久的英语。意外的是，这几个月还大把大把时间地让我学习React以及多线程的最佳实践，总体来说还是很满意的。&lt;/p&gt;

&lt;p&gt;总之，先脚踏实地，埋头苦干，锻炼好自己的英语，前端，有机会也考几个证先吧。&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/12/hello-2020/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/12/hello-2020/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
